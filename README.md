# Java AI Powered
- Curso da DIO sobre desenvolvimento com Java

## Ganhando produtividade em Java com Spring Framework

### Bootcamps DIO: educação Gratuita e Empregabilidade Juntas!
- Já foi concluído no curso de desenvolvimento de jogos

### Contextualizando o Desenvolvimento Web com Spring Boot 3
- Visão Geral
  - Intellij
  - JDK 17+
  - Kotlin 1.7.22
  - Sintaxe básica Kotlin
  - Conhecimento acerca de POO
- Entendendo a arquitetura REST — Parte 1
  - API (Application Programming Interface)
  - Funciona em termos de cliente e servidor
  - API SOAP usam XML
    - Menos flexivel e mais popular antigamente
  - API RPC
    - O cliente conclui uma função (ou um procedimento) no servidor e o servidor envia a saída de volta ao cliente
  - API Websocket
    - O servidor pode enviar mensagens de retorno de chamada a clientes conectados, tornando-os mais eficientes que a API REST
  - API REST
    - O cliente envia solicitações ao servidor como dados
    - O servidor usa essa entrada do cliente para iniciar funções internas e retorna os dados de saída ao cliente
  - O que são API REST?
    - REST significa transferência representacional de estado
    - Clientes e servidores trocam dados usando HTTP
    - O HTTP permite criar, atualizar, pesquisar, executar e remover operações, atuando sob determinados recursos
    - A principal característica da API REST é a ausência de estado
    - http://localhost:1234/hrservices/v1/users/{id}
      - http é o protocolo
      - localhost é o host
      - `1234` é a porta
      - hrservices é o application context
      - v1 é a versão
      - users é o resource
      - `{id}` é o parametro
- Entendendo a arquitetura REST — Parte 2
  - Explicação sobre métodos HTTP e retornos
  - JSON
    - É um formato de troca de dados entre sistemas independentes de linguagem de programação derrivado do javascript
    - É frequentemente utilizado em aplicações Ajax, configurações, banco de dados e (serviços) ‘web’ RESTful
- Overview do Spring Framework
  - Objetivo de facilitar desenvolvimento de aplicações
  - Baseado na IoC (Inversão de Controle) e DI (Injeção de dependência) utilizando beans
  - Spring Boot é utilizado para trazer agilidade com as configurações iniciais
  - Spring Framework tem 20 modulos
  - Spring Boot
    - Abstrair e facilitar a configuração de, por exemplo:
      - Servidores
      - Gestão de dependências
      - Configuração de bibliotecas
      - Métricas e health checks
    - Spring Boot Starters
      - Dependências que agrupam outras dependências com um propósito em comum
      - Exemplo:
        - spring-boot-starter-test
    - Spring Initializr
      - É uma UI que permite a criação de projetos Spring Boot de forma facilitada
- Arquitetura de três camadas com Spring Boot
  - Separa em lógica de apresentação, lógica de negócio e lógica de acesso a dados
  - Torna o sistema mais flexível
  - Arquitetura Projeto Spring
    - Postman Client
      - JSON e DTO
    - Controller
      - API Layer
    - Service
      - Business Logic
    - DAO (repository)
      - Persistence logic
    - DB
  - Arquivo de configuração
    - Ao trabalhar com Spring Boot, nos deparamos com várias configurações que devem ser realizadas
    - O Spring Boot permite utilizar 2 diferentes arquivos de configurações:
      - application.properties
      - application.yml

### Versionamento de código com Git e Github
- Já foi concluído no curso de desenvolvimento de jogos

### Desafios de Projetos: Crie um `Portfólio` Vencedor
- Apresentação
  - É visto por todos da DIO
- PBL, `Portfólio`, Competências e Empregabilidade
  - Aprendizado Baseado em Projetos
  - Bom para demonstrar conhecimentos técnicos
  - É bom para ganhar conhecimento, mas não ajuda a conseguir uma vaga no mercado de trabalho
  - Tenha empatia com pessoas que estudam programação
- A importância dos desafios de projeto, na prática
  - Mostrou o módulo contribuindo num projeto `open source` no github
  - As aulas de construção são melhores que os desafios
  - Todos os projetos são entregues no github
  - README é o arquivo onde fica tudo sobre o projeto
  - Para contribuir para um desafio deve fazer um `fork`
  - É possível ver os projetos no perfil da DIO

### Contribuindo num Projeto Open Source no Github
- Já foi concluído no curso de desenvolvimento de jogos

### Imersão no Spring Framework com Spring Boot

#### Apresentação Inicial
- Abertura
  - Explicação bem rápida sobre o curso
  - Gleyson Sampaio
- Visão geral do curso
  - Imersão no Spring Framework
  - Dez anos de experiência
  - Spring Versus JavaEE
  - O que é Spring Boot?
  - Conceito de IoC / DI
  - Beans \ Autowired \ Scopes
  - Spring Data JPA
- Spring Framework
  - Fundamentos
  - Certificado Java SE 6 Programmer
  - O que é Spring Framework?
    - `Framework Open Source` desenvolvido para a plataforma Java baseado nos padrões de projetos
      - Inversão de Controle
      - Injeção de dependência
    - A sua estrutura é composta por módulos
      - Tem o objetivo de reduzir a complexidade no desenvolvimento de aplicações simples ou corporativas
    - Módulos
      - Data Access / Integration
        - JDBC
        - ORM
        - OXM
        - JMS
        - Transactions
      - Web (MVC / Remoting)
        - Web
        - Servlet
        - Portlet
        - Struts
      - AOP
      - Aspects
      - Instrumentation
      - Core Container
        - Beans
        - Core
        - Context
        - Expression Language
      - Test
  - Spring Versus JavaEE
    - JavaEE tem muita burocracia
    - Spring foi um movimento para simplificar o desenvolvimento
  - Conceito de IoC / DI
    - Inversão de Controle ou IoC (Inversion of Control)
      - Trata-se do redirecionamento do fluxo de execução de um código retirando parcialmente o controle sobre ele e delegando-o para um container
      - O principal propósito é minimizar o acoplamento do código
      - Sem o IoC era necessário criar o objeto e depois utilizá-lo
      - Com o IoC o container cria os objetos necessários
    - Injeção de dependências
      - É um padrão de desenvolvimento com a finalidade de manter baixo o nível de acoplamento entre módulos de um sistema
      - O container tem os objetos reais, mas as implementações são feitas via ‘interface’ por injeção de dependência
  - Beans \ Autowired \ Scopes
    - Beans
      - Objeto instanciado (criado), montado e gerenciado por um container através do princípio da inversão de controle
    - Scopes
      - Singleton
        - O container do Spring IoC define apenas uma instância do objeto
      - Prototype
        - Será criado um objeto a cada solicitação ao container
      - Spring Beans Scopes
      - HTTP
        - Request
          - Um bean será criado para cada requisição HTTP
          - Os objetos existirão enquanto a requisição estiver em execução
        - Session
          - Um bean será criado para a sessão de utilizador
          - Precisamos acessar a mesma solicitação duas vezes para testar os escopos específicos da ‘web’
        - Global
          - `Application scope` cria um bean para o ciclo de vida do contexto da aplicação
          - Objetos compartilhados por toda a aplicação
    - Autowired
      - Uma anotação (indicação) onde deverá ocorrer uma injeção automática de dependência
      - `byName`: buscado um método set que corresponde ao nome do Bean
      - `byType`: considerado o tipo da classe para inclusão do Bean
      - `byConstructor`: usamos o construtor para incluir a dependência

#### Projeto Spring Boot
- Conhecendo o Spring Boot
  - O que é Spring Boot?
    - Enquanto o Spring Framework é baseado no padrão de injeção de dependências
    - O Spring Boot foca na configuração automática
    - Antes do Spring Boot
      - Dependência individual
      - Verbosidade
      - Incompatibilidade de versões
      - Complexidade de gestão
      - Configurações complexas e repetitivas
  - Configurações manuais
    - Antes do Spring todas as configurações eram feitas manualmente
    - O Spring Boot veio para não precisar mais fazer esse processo manualmente
  - Starters
    - São descritores de dependências
    - São pacotes de dependências com todas as dependências necessárias para realizar uma ação
    - Coesão
    - Versões compatíveis
    - Otimização de tempo
    - Configurações simples
    - Foco no negócio
  - Principais starters
    - data-jpa: Integração com o banco de dados via JPA — Hibernate
    - data-mongodb: Integração com banco de dados MongoDB
    - `web`: Inclusão do container Tomcat para aplicações REST
    - web-services: WebServices baseados na arquitetura SOAP
    - batch: Implementação de `JOBs` de processos
    - `test`: Disponibilização de recursos para testes unitários como JUnit
    - openfeign: Client HTTP baseado em interfaces
    - actuator: Gestão de monitoramento da aplicação
  - Configuração de fábrica
- Primeiros passos
  - Criando um projeto com o Initializr
    - https://start.spring.io/
  - Importando o projeto maven no Intellij
    - Descompactar o projeto gerado no Initializr
    - Abrir no Intellij
  - Conhecendo a estrutura spring boot
    - src/main
      - pasta raiz dos projetos java
      - java
        - Dentro desse pacote que fica o código java
        - Existe a classe principal que inicia o spring boot
    - pom.xml
      - A propria aplicação tem um conceito de spring boot
    - test
      - Já tem uma classe de teste da aplicação
    - application.properties
      - Todas as configurações da aplicação serão feitas nesse arquivo
  - Bean e CommandLineRunner
    - Para dizer que uma classe é um Bean que será gerenciado pelo Spring deve utilizar a anotação @Component
    - O CommandLineRunner é utilizado, pois, não utilizamos o pacote, `web` do spring boot
- Beans versus Components
  - Quando usar @Bean
    - Utilizado quando não tem acesso ao código-fonte
    - Exemplo é o CommandLineRunner
  - Quando usar @Component
    - Serão componentes scaneados pela aplicação
    - Utiliza @Component quando tem acesso ao código-fonte
    - Evita dar o comando `new` para utilizar os métodos da classe
  - Implementar a IoC e DI
- Scopes - Singleton ou Prototype
  - Conceito de Scope
  - Configurando objeto Singleton
    - Apenas uma instância na aplicação
  - Configurando objetos Prototype
    - Pode ter vários de acordo com necessidade da aplicação
- Properties value
  - O poderoso application.properties
    - Pode ser colocado o valor dentro do application.properties
  - @Value
    - Com o @Value pegar o valor que foi definido no application.properties
  - Default Value
- Configuration properties
  - O poderoso application.properties
  - @ConfigurationProperties(prefix)
    - Deixa centralizado numa classe as propriedades
- Conceito de ORM e JPA
  - O que é ORM
    - Object Relational Mapping, em português, mapeamento objeto relacional
    - É um recurso para aproximar o paradigma da orientação a objetos ao contexto de banco de dados relacional
    - O uso de ORM é realizado através do mapeamento de objeto para uma tabela por uma biblioteca ou framework
  - Java Persistence API
    - É uma especificação baseada em ‘interfaces’
    - Através de um framework realiza operações de persistência de objetos em Java
    - Hibernate, EclipseLink, TopLink, OpenJPA
  - Mapeamentos
    - Identificação
    - Definição
    - Relacionamento
    - Herança
    - Persistência
  - EntityManager
    - É uma estrutura de camadas para acessar os dados no banco de dados
- Spring Data JPA
  - CrudRepository
  - JPARepository
  - PagingAndSortingRepository
  - @Query
  - @Param
  - Com o Spring Data JPA não é mais necessário configurar o repository
  - Ele já oferece o repository pronto criando uma interface que que extende o repository
- Conexão com Postgres
  - Todas as configurações para conectar com o Postgres
  - Tomar cuidado com o nome da classe como User, pois é uma tabela reservada do banco de dados
- JPA repository
  - O DAO era utilizado antes do repository
  - O repository já traz todas as operações de um CRUD
  - Para consultas customizadas pode-se utilizar Query Method ou Query Override
  - Query Method
    - Utiliza JPQL
    - O nome do método é utilizado como se fosse uma query do banco de dados
  - Query Override
    - Utilizado para consultas nativas
    - Bom quando o nome da Query Method fica muito grande

#### Conclusão
- Conclusão e para saber mais
  - Dominamos o Spring Boot Framework
  - Criamos um projeto
  - Exploramos o IoC / DI
  - Conhecemos a central de propriedades
  - Interagimos com o banco de dados

### Criando uma API REST Documentada com Spring Web e Swagger

#### Apresentação Inicial
- Apresentação e visão geral do curso
  - Criar uma API REST documentada com Spring Web e Swagger
  - Criar um projeto Web
  - Configurando Controllers
  - Documentar a API com Swagger
  - Tratamento de exceções com Handlers

#### Projeto Spring Boot
- Criando uma REST API
  - REST é um guia de boas práticas
  - RESTFul é a capacidade de determinado sistema aplicar os princípios de REST
    - Cliente/Servidor
    - Interface uniforme
    - Stateless
    - Cache
    - Camadas
  - Nível de maturidade
    - Definido em 4 níveis
    - Level 0 The swamp of POX -> Ausência de regras
    - Level 1 Resources -> Define os nomes dos recursos e define os verbos
    - Level 2 Http Verbs -> Valida a aplicabilidade dos verbos
    - Level 3 Hypermedia Controls -> HATEOAS
    - Glory of REST
- RestController
  - Uma classe contendo anotações específicas para a disponibilização de recurso HTTP baseados nos nossos serviços e regras de negócio
- Documentando a nossa API com SWAGGER
  - É um centralizador de API
  - Atualmente basta adicionar uma dependência 
  ```
  <dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.3.0</version>
  </dependency>
  ```
  - E acessar a URL http://localhost:8080/swagger-ui/index.html#/
- Habilitando o tratamento de exceções de negócio com handlers
  - Conseguir ajudar o usuário a entender o problema
  - Pode Utilizar o ControllerAdvice
  - Pode utilizar o ExceptionHandler em cada método
  - Pode utilizar o ResponseStatusExceptionResolver
  - Pode utilizar o RestControllerAdvice
    - Centraliza num único componente todas as exceções
    - Existem formas melhores de fazer o controle de exceção
    - A centralização das exceções de campo requerido foi boa

#### Conclusão
- Conclusão e para saber mais
  - Criamos um projeto WEB
  - Estruturamos nossos controllers
  - Documentamos a nossa API
  - Habilitamos tratamento de exceções
  - Interagimos com a API via Postman

### Criando uma API REST com Spring Security

#### Apresentação Inicial
- Apresentação e visão geral do curso
  - Spring Boot Security
  - Introdução sobre segurança
  - Habilitando segurança com spring
  - Configure Adapter
  - Autenticação com banco de dados
  - JWT - Json Web Token

#### Spring Boot Security com JWT
- Habilitando segurança com Spring
  - É apenas um grupo de filtros servlet que ajudam você a adicionar autenticação e autorização ao seu aplicativo ‘web’
  - É configurado um utilizador e senha padrão, quando se cria um projeto com spring security
  - Utilizar: user
  - Senha: gerada a cada execução do projeto
- Autenticação simples
  - É feita no application.properties
  ```
  spring.security.user.name=user
  spring.security.user.password=user123
  spring.security.user.roles=USERS
  ```
  - Tem como gerar mais de um utilizador em memória
  - O curso está com código desatualizado
- Configure Adapter
  - Centraliza as configurações de acesso a recursos
  - O curso está com código desatualizado
  - A versão mais recente do spring security é de fevereiro de 2024 nesse momento
- Autenticação com Banco de dados
  - Foi utilizado o banco `H2`
  - O curso está com código desatualizado
  - A parte mais difícil foi criar um componente separado para a geração do encode da senha
- JWT - JSON Web Token - Parte 1
  - É um JSON com as informações do utilizador da aplicação
  - Constituído por um `Header`, `Payload` e `Signature`
- JWT - JSON Web Token - Parte 2
  - Adicionando dependência do JWT
  - Pacotes da aplicação
    - model
    - dto
    - repository
    - service
    - controller
    - security
  - Classes da aplicação
    - SwaggerConfig — Não precisa mais porque a dependência já configura para nós
    - JWTObject
    - JWTCreator
- JWT - JSON Web Token - Parte 3
  - Configuração antiga de 2022
  - Precisa utilizar o Java 8 e algumas dependências do maven para funcionar
- JWT - JSON Web Token - Parte 4
  - Testes com o JWT
  - Banco de dados não funcionou para acessar o `H2`

#### Conclusão
- Conclusão e para saber mais
  - Habilitamos a segurança na nossa API
  - Conhecemos algumas formas de configurar segurança
  - Configuramos manualmente a segurança da nossa API
  - Consultamos os nossos utilizadores em banco de dados
  - Melhoramos a segurança da nossa API com JWT

### Explorando Padrões de Projetos, na Prática com Java
- Como usar os desafios de projeto para criar o seu `portfolio`
  - Explicação de como entregar os desafios
- Apresentação Inicial
  - Os padrões de projeto serão feitos com Java Puro
  - Alguém está sentado na sombra hoje porque alguém plantou uma árvore há muito tempo `Warren Buffet`
- Padrões de projeto
  - Passo 1 — Padrões de Projeto
  - Passo 2 — Praticando com Java Puro
  - Passo 3 — Praticando com Spring
  - Passo 4 — Desafio de Projeto
  - A principal referência foi feita em 1995 no livro `Design Patterns: Elements of Reusable Object-Oriented Software`
  - Divido em:
    - Criacionais
    - Comportamentais
    - Estruturais
  - Falar é fácil. Mostre-me o código `Linus Torvalds`
- Praticando com Java Puro: Singleton
  - Permitir a criação de uma única instância de uma classe e fornecer um modo para recuperá-la
- Praticando com Java Puro: Strategy
  - Simplificar a variação de algoritmos para a resolução de um mesmo problema
- Praticando com Java Puro: Facade
  - Prover uma ‘interface’ que reduza a complexidade nas integrações com subsistemas
- Praticando com Spring: Introdução
  - Relacionar padrões de projeto com o Spring
  - Singleton: @Bean e @Autowired
  - Strategy: @Service e @Repository
  - Facade: Spring Data JPA e ViaCEP
- Praticando com Spring: Conhecendo o Projeto Base
  - CrudRepository é uma Strategy
- Praticando com Spring: Padrões de Projeto numa API REST
  - Desenvolvendo o repository do cliente
  - Testando a API
  - Funcionou tudo corretamente
- Desafio de Projeto
  - Pelo que entendi é para criar um projeto com algum `design patterns`
  - Vou usar o meu projeto com todos os `design patterns`
- Entendendo o desafio
  - Entregar um projeto com algum `design pattern` implementado
  - Entreguei o meu repositório com o estudo sobre todos os `design pattern` do GoF

### Desafios de código Java intermediários: Design Patterns
- Algumas questões sobre `Design Patterns`
- Todas as questões foram respondidas na plataforma

### Aula Inaugural - Java AI Powered
- Autodescrição é uma coisa ótima nos vídeos
- Curso voltado para quem quer trabalhar fora do Brasil
- Curso voltado para utilizar IA na programação
- Vídeo de 1 hora e meia
- O recomendado são 10 horas por semana
- As empresas buscam por especialistas

## Explorando Testes e Arquiteturas Java de Alta Escalabilidade

### Introdução a Testes de ‘software’
- Introdução
  - Introdução
    - Apresentação do instrutor do curso
    - Atua desde 2012
    - Entender o que é testes de software e seus principais conceitos
    - Compreender como essa disciplina permeia o desenvolvimento de ‘software’
    - Entender os diversos testes e as suas finalidades
    - Falar um pouco sobre qualidade de ‘software’
    - Definição e conceitos básicos
    - Níveis e técnicas de teste
    - Testes não funcionais
    - A pirâmide de testes
- Definição e conceitos básicos
  - Definição de Testes
    - Evitar que o cliente final utilize outro sistema por questão de erro
    - Como testar?
      - Valor -> Saque -> Resultado
    - Erros em produção são muito caros
    - Chega a casa dos milhões
    - Definição (Dias Neto)
      - É o processo de execução de um produto para determinar se ele atingiu as suas especificações funcionou corretamente no ambiente para o qual foi projetado
    - Definição (Edsger W. Dijkstra)
      - Testes podem ser usados para mostrar a presença de erros, mas nunca para mostrar a sua ausência
  - Evolução de Testes na engenharia de ‘software’
    - Cascata
      - Especificação
      - Projeto de software
      - Implementação
      - Testes
      - Implantação
    - Desenvolvimento ágil
      - Meet & Plan
      - Design
      - Code & Test
      - Release
      - Feedback
  - Conceitos básicos
    - Defeito: É o erro do sistema ou `Bug`
    - Erro: Com o desenvolvedor
    - Falha: Com o utilizador final
    - Verificação: Verificar se o sistema está construido da forma correta
    - Validação: Verificar se as regras de negócio estão corretas
- Níveis e técnicas de teste
  - Níveis de teste
    - Unidade
      - JUnit
    - Integração
      - Testar os componentes entre si
      - Banco de dados
      - API
      - Entre outros
    - Sistema
      - Testar num ambiente de homologação
      - Somente para alguns utilizadores
    - Regressão
      - Testar se as novas features não irão quebrar as features existentes
      - Utiliza o Selenium
    - Alpha: Com certeza vai ter algo para ajustar 
    - Beta: Já está próximo do que é esperado 
    - Cannary 
      - Deploy canário
      - Somente algumas pessoas têm acesso às novas versões
    - Aceitação
      - Já foi para produção
      - Antigamente era mais formal
      - BDD automatizou esse processo
  - Técnicas de teste
    - Cada nível de teste possui técnicas diferentes
    - Caixa Branca
      - Também conhecida como teste estrutural
      - Validar dados, controles, fluxos, chamadas
      - Garantir a qualidade da implementação
      - Níveis: Unidade, Integração e Regressão
    - Caixa Preta
      - Teste funcional
      - Verificar saídas usando várias entradas
      - Teste sem conhecer a estrutura interna do ‘software’
      - Níveis: Integração, Sistema e Aceitação
    - Caixa Cinza
      - Mescla técnicas de caixa branca e caixa preta
      - Analisa parte lógica e também funcionalidade
      - Exemplo: ter acesso à documentação do funcionamento do código
      - Engenharia reversa
- Testes não funcionais
  - O que são testes não funcionais
    - Testes não funcionais estão ligados a requisitos não funcionais
      - Comportamento do sistema
      - Performance
      - Escalabilidade
      - Segurança
      - Infraestrutura
    - Testes não funcionais visa testar partes do ‘software’ que não são associados as regras de negócio, mas sim a requisitos não funcionais
    - São utilizadas ferramentas que usam técnicas para apurar o comportamento do sistema em determinadas circunstâncias
    - Teste de carga
      - Realizado para verificar qual o volume de transações, acessos simultâneos ou utilizadores que um servidor/‘software’/sistema suporta
      - Pontos de atenção
        - Objetivos para clareza de resultados
        - Ambiente
        - Cenários
        - Execução de testes
        - Análise de resultado
      - Gattling Load Testing
      - Apache JMeter
    - Teste de estresse
      - Realizado para submeter o ‘software’ a situações extremas
      - O teste de estresse baseia-se em testar os limites do ‘software’ e avaliar o seu comportamento
      - Avalia-se até quando o ‘software’ pode ser exigido e quais as falhas decorrentes do teste
      - Apache JMeter
    - Teste de segurança
      - É um processo crítico de segurança cibernética que visa encontrar vulnerabilidades em sistemas, ‘software’, redes e aplicativo
- A pirâmide de testes
  - A pirâmide de testes
    - Testes unitários (rápido e isolado)
    - Testes de serviços (mediano e isolado medianamente)
    - Testes de `UI` (demorado e integrado)
    - Software Testing Ice Cream Cone Anti-Pattern
      - Testes manuais
      - Testes automatizados
      - Testes de integração
      - Testes unitários
    - Tente fugir desse pattern
- Encerramento
  - Encerramento
    - É um curso somente de introdução para ter uma base sobre testes de ‘software’
    - Conceitos básicos e a evolução da disciplina de testes
    - Terminologia
    - Níveis e técnicas de teste
    - Testes não funcionais
    - Pirâmide de testes

### Testes Unitários com JUnit
- Apresentação do curso
  - Apresentação do curso
    - Entender a motivação de escrever testes unitários
    - Conhecer o que é o JUnit
    - Configurar a ferramenta para utilizar nos seus projetos java
    - Aprofundar nos recursos que ele provê para construir testes unitários efetivos
    - Por que escrever testes unitários?
    - Hello World, Junit!
    - Aprofundando nos recursos
    - Recursos das IDEs
    - Boas práticas
    - Conclusão
- Por que escrever testes unitários
  - Por que escrever testes unitários
    - Entender o que é teste unitário e a sua importância
    - O que são testes unitários?
      - Também chamado teste de unidade
      - Testar a menor unidade de código possível
      - Unidade: função, método, classe
      - Testar uma aplicação na sua menor parte
      - Geralmente escrito em tempo de desenvolvimento
    - Exemplo simples demonstrado
    - Por que escrever testes unitários?
      - Compreender o código fonte
      - Corrigir erros com segurança
      - Refatorar código sem introduzir erros
      - Entregar com segurança uma nova versão
      - Pirâmide de testes
      - Testes unitários como métrica de qualidade (confiabilidade)
      - Cobertura de testes
      - Automação na execução de testes
      - Cultura de agilidade
- Hello World, JUnit
  - Hello World, Junit
    - Falar um pouco sobre a história do JUnit
      - Ferramenta de código aberto para criação de testes unitários 
      - Criado por Erich Gamma e Kent Beck
      - Kent Beck é o criador do TDD
      - Erich Gamma faz parte da `Gang of Four` que criou o conceito de Padrões de Projeto
    - Falar um pouco sobre a versão atual
      - Versão atual 5
      - Junit Platform
        - É o componente que executa os testes
      - JUnit Jupiter
        - Todas as classes e interfaces ficam dentro dele
      - JUnit Vintage
        - Faz integração com as versões anteriores
    - Configurar em projeto Maven e Gradle a ferramenta
      - Basta adicionar a dependência
- Aprofundando nos recursos
  - O básico para testar
    - Conhecer em detalhes os pricipais recursos que o JUnit provê
  - Mais algumas asserções
    - Algumas dicas para testes
  - After e Before
    - All: executado depois que todos os testes forem finalizados
    - Each: executado em cada teste
  - Assumptions e testes condicionais
    - Assumptions: Os testes são executados somente se a Assumption estiver correta
  - Testando exceptions
    - assertThrows e assertDoesNotThrows
  - Ordenando testes
    - OrderAnnotation
    - MethodName
    - Random
    - DisplayName
- Recursos de testes nas IDEs
  - Conhecer o básico para executar testes unitários nas IDEs mais utilizadas pelo mercado
  - Visual Studio Code
    - É possível executar testes no VS Code
    - Precisa instalar uma extensão
  - Eclipse
    - O eclipse é mais bonito as execuções de teste
    - Podemos dizer que traz mais detalhes dos testes
    - Tem como definir o valor de algumas variaveis
  - Intellij IDEA
    - A interface do Intellij é mais limpa
    - Também aceita realizar debug no código
- Boas práticas
  - Boas práticas
    - Conhecer boas práticas adotadas ao escrever testes unitários
    - Preocupe-se com os nomes
    - Preocupe-se com a facilidade de leitura
    - Procure escrever o código de teste o mais próximo possível do código de execução
    - Veja um pouco sobre TDD
      - Escreva um teste que falhe
      - Faça o código funcionar
      - Elimine redundância
    - Busque uma padronização de nomenclatura
    - Testes precisam ser determinísticos
      - Um teste não pode influenciar no outro
    - Economize tempo automatizando
      - Ferramentas de cobertura de código (JaCoCo)
      - Automatize a execução dos seus testes
- Conclusão do curso
  - Conclusão do curso
    - Motivação
    - Configuração
    - Principais recursos
    - Usando os recursos das IDEs
    - Boas práticas

### Desenvolvendo testes utilizando Mockito
- Apresentação do curso
  - Conhecer o Mockito e seus principais recursos para auxiliar na escrita de testes unitários
- Introdução ao Mockito
  - Entender conceito de mock
  - Configurar um projeto utilizando mockito
  - Conhecer um pouco mais sobre mockito
  - Funciona com Spring, Kotlin, Java
  - Um pouco sobre as facilidades que o Mockito fornece
  - Como configurar o Mockito no seu projeto
- Mockando objetos
  - Entender como mockar objetos no Mockito
- Espiando objetos
  - Entender como usar a função Spy do Mockito
  - Entender a diferença entre Mock e Spy
- Capturando argumentos
  - Entender como funciona a fução Captor do Mockito
- Manipulando retornos
  - Entender como usar os Matchers que estão disponíveis no Mockito
  - Entender como manipular retornos no Mockito
  - São os any do Mockito: any(), anyString(), anyInt(), anyBoolean()
- Mockando métodos estáticos
  - Entender como fazer mock de métodos estáticos
  - Precisa usar a dependência mockito-inline
- Conclusão
  - Introdução
  - Mock
  - Stubbing (when, thenReturn, thenThrow)
  - Verify
  - Captor
  - mockito-inline
  - Se aprofundar
    - BDDMockito
    - Integração Spring

### Introdução aos conceitos de API e Clean Architecture

#### Conceitos iniciais sobre Arquitetura Rest
- Introdução ao curso e objetivos
  - Implementação de API Avengers com Springboot e Kotlin
  - Deploy vai ser feito no heroku
  - Banco de dados postgres
  - Agenda de conceitos
    - Estilo Arquitetural REST
    - Conceito de API First
    - API RESTFul com Spring Boot
    - Clean Architecture
      - Ports and Adapters
    - Sistema de gestão de banco de dados
      - NoSQL
      - Relacional
    - Postman
- Conceito inicial sobre REST
  - É um acrônimo de representação de tranferência de estado (REpresentational State Transfer)
  - É um estilo arquitetural apresentado por Roy Fielding (HTTP e REST)
  - Interoperável e agnóstico a linguagem ou tecnologia (meio de integração entre sistemas de qualquer stack tecnológica)
- O que são Constraints
  - Interface uniforme
    - Baseado em recursos, ‘interfaces’ por onde o cliente se comunica com o servidor
  - Cliente-Servidor
    - Cliente e servidor podem existir e serem desenvolvidos separadamente, são independentes
  - Sem estado
    - O servidor não guarda estado, sessão, necessário sempre, a cada requisição, caso necessário informar o servidor de quem está requrendo o dado especifíco
  - Cache
    - Funcionalidade que elimina, dados algumas configurações, voltar ao servidor, se a requisição se repetir dentro de um tempo
    - `Cache` pode ser gerenciado em modo cliente ou do lado servidor
  - Sistema em camadas
    - Por ser sem estado, permite distribuir as implantações ou recursos
      - Exemplo: API num servidor, data storage em outro e sistema de autenticação num terceiro servidor
  - Código sobre demanda (opcional)
    - Possibilidade de retornar "executáveis" via API para renderização de algum componente se necessário
- Sobre resource naming guide e catching
  - Resource Naming Guide
    - Estratégia para expor recursos (plural ou singular)
    - Estrutura de nomes para recuperar recursos, armazenar, detalhe, nomes compostos, passar parametros (query param, path param)
    - URI (endereçamento para um determinado recurso)
  - Caching
    - Capacidade de manter cópias de um response armazenadas por um tempo determinado
    - Elementos
      - Tempo de expiração
      - Cache-Control
      - E-tag
      - Last Modified
    - Cuidados
- Versionamento
  - Permite evolução de uma API sem trazer quebra de contratos para os clientes (mudanças em requests e response, remoção de API)
  - Tipos
    - URI: http://api.example.com/v1, http://apiv1.example.com
    - Header Customizado: Accept-version: v1
    - Content Negotiation (Accept Header):
      - Accept: application/vnd.example.v1+json
      - Accept: application/vnd.example+json;version=1.0
- Verbos HTTP
  - GET
  - POST
  - PUT
  - PATCH
  - DELETE
- Códigos HTTP
  - Códigos HTTP
    - 1XX — Informações
    - 2XX — Sucesso na requisição
    - 3XX — Redirecionamento
    - 4XX — Erro no lado do cliente
    - 5XX — Erro no lado do servidor
- Idempotência
  - Uma requisição idempotente é aquela que, independente da quantidade de vezes que se execute, o efeito é o mesmo que da primeira execução
  - POST — Altera estado no servidor, cria recurso, logo, não é idempotente
  - GET, PUT, DELETE, HEAD, OPTIONS e TRACE são idempotentes
- N+1 em REST APIs
  - Quando são feitas muitas requisições para buscar os dados necessários
  - Montar uma única resposta com todos os dados para um único request

#### Conceitos sobre Arquitetura Hexagonal
- Conceitos iniciais sobre API FIRST
  - Antes de começar a desenvolver é necessário definir os contratos da aplicação
- Agenda - API: Pré-requisito e Arquitetura Hexagonal aplicado ao projeto
  - Application Layer
    - Configs
    - Controllers (conceito de fronteira)
      - DTOs (request, response)
      - Bean Validations
      - Init Binders (validações customizadas)
      - Error Handlers
- Agenda - API: Domain Layer, Resource Layer e Testes
  - Domain Layer
    - Entidades
    - Portas (interfaces)
    - Services
  - Resource Layer
    - Spring data repository
    - Proxy repository (composição com spring data repository e implementação ‘interface’ repository do domínio)
    - Entidades mapeadas com anotações de acordo com tecnologia de banco de dados escolhida para o projeto
  - Testes
  - https://start.spring.io
  - Dockerização
    - `Script` e configuração para criação de imagem
    - Compose yaml do serviço
    - Usando o docker-compose para subir o serviço
  - Heroku
    - Criando uma aplicação
    - Conectando com o github do projeto
    - Automatizando o pipeline de deploy
- Agenda - Clean Architecture
  - Principal objetivo de uso de Clean Architecture é fornecer aos desenvolvedores uma maneira de organizar o código de forma que encapsule a lógica de negócios, mas mantenha-o separado do mecanismo de entrega
  - Vantagens:
    - Independência de ‘interfaces’ de usuário
    - Independência da stack tecnológica utilizada para acesso aos dados ou expor entradas
    - Testável
    - Carga cognitiva de entendimento do projeto, regras de negócio
    - Facilita manutenabilidade
- Conceitos sobre sistema de gestão de banco de dados
  - Será utilizado Postgres
  - Postgres e MySQL (RDBMS SQL)
    - OK: ACID transactions
    - OK: SQL Support 
    - OK: Standardized
    - NOK: Horizontal Scaling
    - NOK: High Availability
  - MongoDB, Cassandra e Redis (NoSQL)
    - OK: Horizontal Scaling
    - OK: High Availability
    - NOK: ACID transactions
    - NOK: Standardized
    - NOK: SQL Support
  - Cloud Spanner, VOLTDB e CockroachDB (NewSQL)
    - OK: ACID transactions
    - OK: SQL Support
    - OK: High Availability
    - OK: Horizontal Scaling
    - NOK: Standardized
- Comentários adicionais e conclusão do curso
  - Obrigado pela atenção
  - Respondendo a perguntas

### Introdução a Arquitetura Hexagonal com Spring Boot e Kotlin

#### Montando a estrutura do projeto
- Organizando o ambiente de desenvolvimento
  - Configuração inicial do projeto com todas as dependências necessárias
- Explicando o README.md e as dependências do projeto
  - Irá utilizar API First
  - Ainda não fez a aplicação funcionar
  - Está somente configurando as coisas
- Configurações no Swagger Editor
  - Montando uma documentação no Swagger Editor
  - Deu um exemplo bem pobre de um GET
- Organizando o projeto conforme o modelo de Arquitetura Hexagonal
  - Criando os pacotes da aplicação
  - Criou somente o request, response e resource
- Criando as classes e métodos da camada de aplicação e domínio
  - Criando primeiros métodos de Controller e Entidade
- CRUD: Parte 1
  - Criando o repository
  - Não é o repository do JPA é somente um conversor
  - Criando GET e POST do CRUD
- CRUD: Parte 2
  - Finalizando o CRUD
  - Ficou faltando o Delete
- Rodando a aplicação e adicionando outras configurações
  - Criando o delete para completar o CRUD
  - Criando configurações do application.yaml
  - Nossa senhora! É triste ver configurações antigas novamente
  - E o pior de tudo é que foi logo na parte em que eu tinha mais interesse
- Criando o arquivo de configurações e respondendo perguntas
  - Terminando as configurações
  - As configurações do docker mudam com muita facilidade
  - A pior parte é que se utilizar versões antigas fica vulnerável
  - Para rodar os arquivos do docker
    - docker-compose -f avenger-api-resources.yaml up -d
    - docker-compose -f avenger-api-resources.yaml down -d
  - Muitas coisas configuradas de forma muito complicada
  - Existem vários jeitos mais simples de realizar a configuração de infraestrutura

#### Implementação da camada de infraestrutura e fazendo deploy com Heroku
- Recaptulando a aula 1 e overview da aula 2
  - Resumo do que foi feito
  - Fazer a parte de banco de dados e testar na heroku
- Criando a camada de infraestrutura
  - Criando a camada que irá se comunicar com o banco de dados
- Conceito "porta e adaptador"
  - Explicando sobre porta e adaptador
- Configurando o docker
  - Trabalhando na parte do docker para subir a aplicação
  - Deu erro para subir a aplicação e ficou por isso mesmo
  - Falou que vai corrigir e colocar no repositorio com a correção
- Corrigindo a migração e fazendo testes no postman
  - Mostrando a aplicação subindo com dados configurados diretamente no arquivo de configuração
- Subindo a aplicação com o Heroku
  - Testou o PUT e DELETE
  - Subir para o heroku
  - Precisa criar uma conta
- Configurando a aplicação no Heroku e finalizando o projeto
  - A configuração será feita agora
  - Precisou ser ajustada várias configurações
  - Preço R$35 por mês ou 7 dolares
  - A parte de deploy já é automática
- Respondendo perguntas dos Devs
  - Respondendo às perguntas
  - Poderia utilizar Quarkus?
    - Seria necessário configurar o quarkus
  - Heroku possui configuração de `pipeline`
    - Pode ser configurado da forma que quiser

### Desmistificando microserviços, BFF e `DDD`
- Introdução aos Microserviços
  - Apresentação do curso
    - Explicação inicial sobre `DDD e BFF`
    - Devemos conseguir identificar os pontos de aplicabilidade do `DDD` numa solução de microsserviço ou backend for frontend
    - Saberemos qual a importância de uma boa modelagem das camadas ao propor uma solução
    - Entendimento sobre MS e BFF
    - Domain-Drive Design
    - Saber como e onde aplicar
  - Microserviços (MS)
    - Monolítico
      - HTML, JavaScript, MVC
      - Serviço
      - Acesso a dados
    - Microserviços
      - Quebra em pequenas estruturas
      - Possui um frontend e vários serviços de backend
      - Microserviços podem ser do frontend também
      - Pergunta sobre segurança nos microserviços
- Entendendo BFF e DDD
  - Back-end For Front-end (BFF)
    - É uma API REST ou qualquer outra API
    - Tem um contrato conforme o aplicativo que está se comunicando
    - Ganha em desempenho, tamanho do retorno, entre outras vantagens
    - BFF também formata os dados para exibição nos componentes do frontend
    - É uma forma de centralizar as chamadas de vários microserviços
  - Domain-Driven Design (DDD)
    - Definindo domínio rico em aplicações de microserviços e BFF
    - TDD: Teste falha e depois tem que implementar para funcionar
    - BDD: Mistura do teste com regra de negócio
      - O grande problema do BDD é a falta de inglês nos brasileiros
    - DDD:
      - Introdução feita em 2003 por `Eric Evans`
      - É uma filosofia combinada num `Design Pattern`
      - Fácil de compreender
      - Difícil de aplicar
      - Um guia para criar uma modelagem com base no negócio
      - Domine a teoria e não a prática
      - O modelo e o coração do `design` dão forma um ao outro
      - O modelo é a espinha dorsal de uma linguagem utilizada por todos os membros de um grupo
      - O modelo é um conhecimento destilado
- Aplicabilidade
  - DDD: Lite
  - Tenha o context map definido e coeso
  - DDD não é quebrar a arquitetura em camadas
  - Leia sobre `Design Patterns`
  - Estrutura
    - Aggregates
      - Repositories
      - Factories
        - Value Objects
        - Entities
    - Services
    - Model-Driven Design
    - Smart UI
    - Layered Architecture
  - `Score Card DDD`
    - Se o seu projeto contém isso
    - Pontos
    - Considerações de apoio
  - Erros comuns
    - Permitir que o meio de persistência influencie diretamente nas entidades
    - Não se envolver com os donos do negócio
    - Ignorar a linguagem comum
    - Não ter conhecimento dos limites de contexto
    - Entidades anêmicas
    - Deixar toda a lógica por conta do domínio
    - Deixar de focar no negócio e olhar para tecnologias

### Arquitetura Orientada a Eventos com Java, Spring Boot e Kafka

#### Aprenda como relacionar Java, Spring Boot e Kafka
- Conceitos iniciais
  - Programação orientadas a eventos
  - Consegue ter um controle melhor com uma aplicação baseada em eventos
- Diagramando o projeto: Parte 1
  - Diagrama sobre programação orientada a eventos
- Diagramando o projeto: Parte 2
  - Na programação orientada a eventos sempre tem um evento e espera um retorno desse evento
  - Fica mais fácil de escalar a aplicação com esse modelo
  - Esse modelo é mais complexo
- Dúvidas e comentários
  - Respondendo dúvidas e comentários
  - Diferença entre tópico e partição
    - Na fila vai distribuir os eventos entre os consumidores (partições)
    - No tópico todos os consumidores recebem todos os eventos
- Por dentro da interface da plataforma docker e requisitos básicos
  - Para fazer o módulo precisa do docker
  - Kafka foi instalado no docker e iniciado
- Preparação da IDE Offset Explorer
  - kafkatool.com/download.html
  - Download e configuração do Offset Explorer
  - Funcionou somente a versão 2 do Offset Explorer com kafka e zookeper
  - Com a versão 3 ele roda corretamente no docker, mas não funciona no Offset Explorer

#### Colocando a mão na massa
- Preparando o projeto com Spring Boot
  - Criar o projeto no Initializr
- Desenvolvimento inicial do projeto no Intellij
  - Explicando as configurações necessárias no projeto para utilizar o Kafka
- Testes iniciais da aplicação
  - Primeiros envios de mensagens pelo kafka
- Desenvolvimento do serviço de consumidor
  - Parte de criar o consumidor dos eventos
- Finalizando a conexão e alteração de dados
  - Finalizando o consumidor
  - Precisa fazer a gravação no banco de dados
  - Precisa retornar para a fila que o dado foi salvo
- Estrutura do projeto no github e comentários finais
  - Comentários finais e projeto no github

### Desenvolvendo um sistema para eleição usando Quarkus Framework
- Apresentação do `Expert`
  - Lab com Quarkus
- Orientações gerais e expectativas da aula
  - Planejamento do escopo
    - Definição de escopo
      - Candidatos são listados, cadastrados e editados
      - Todos os candidatos registrados participam de uma eleição, quando for iniciada
      - Candidatos recebem votos de eleitores
      - Resultado disponível em tempo real
      - Requisitos não funcionais
        - Confiabilidade
        - Disponibilidade
        - Interoperabilidade
        - Escalabilidade
    - Proposta arquitetural
      - OpenTelemetry
      - GrayLog e OpenSean
      - Traefik
      - Redis
    - Proposta técnica
      - Conteinerização
        - Docker
          - Explicação sobre o docker
        - Docker compose
          - Arquivo onde é definido as configurações necessárias para executar uma aplicação
      - Tráfego
        - Traefik
          - É um ‘software’ de roteamento de tráfego e balanceamento de carga projetado para ser usado no docker
          - Interessante para ser utilizado em containers e Kubernetes
      - Armazenamento
        - MariaDB
          - Basicamente é o MySQL só que mais código aberto
        - Redis
          - Sistema de chave valor em memória
      - Observabilidade
        - Graylog
          - Plataforma de gerenciamento de logs e análise de dados em tempo real
        - OpenSearch
          - Plataforma de busca e análise de dados em tempo real
          - Baseado em Elasticsearch
          - Compatível com o Kibana, Logstash e Beats
        - MongoDB
          - Banco de dados NoSQL
          - Orientado a documentos
        - Jaeger Tracing
          - Plataforma de rastreamento
      - Linguagem de programação
        - Java 17
      - Framework
        - Quarkus
          - Framework de código aberto para desenvolvimento de aplicativo Java
          - Não precisa da JVM para executar aplicativo foi com quarkus
      - Testabilidade
        - Junit
          - Teste de unidade
          - Integração com Mockito e TestContainers
        - TestContainers
          - Utilizado para teste de componentes
          - Simula um banco de dados ou outro componente
      - Mapeamento Objeto Relacional
        - Hibernate
          - Framework de mapeamento objeto relacional
          - Hibernate oferece cache de objetos
      - Migração
        - Flyway
          - Migração de banco de dados
          - Ótimo para projetos complexos
- Preparação do ambiente e configuração
  - SDKMAN!: Java 17 + GraalVM + Native Image
    - quarkus create app
  - Docker compose: Contêiners
  - Build e Versionamento
  - Deployment
  - Sinceramente o pior conteúdo que já vi da DIO até o momento
  - Explicou tudo, mas já estava tudo pronto
  - Explicações rápidas para cada tecnologia e segue
  - Nenhum desenvolvedor consegue aprender com um método de ensino desses
  - É serio mesmo que o cara fala todos os comandos que devem ser executados e não executa nenhum?
  - Eu pensei que seria feito o aplicativo do zero
  - Não que era só executar o que já está feito sem entender nada e dar sorte de funcionar
  - Dois GygaBytes de tamanho para baixar os containers (Pelo amor de Deus)
  - 10 minutos só para baixar as imagens
  - 10 containers para rodar 1 aplicação (Computador travou até o bloco de notas)
- Setup das aplicações quarkus e discussão arquitetural
  - Executar o quarkus no Intellij
  - Pelo amor de Deus esse negócio de pausar para fazer uma leitura é ruim
  - Arquitetura Hexagonal
    - Coloca o núcleo da aplicação no centro
  - Arquitetura Limpa
    - Coloca a lógica de negócios no centro
  - Arquitetura Cebola
    - Coloca a lógica de negócios no centro
  - Para executar o quarkus
    - Entrar na pasta do projeto e executar comando `quarkus dev`
    - Precisa do `JAVA_HOME` configurado
  - Quarkus Dev Service
    - Depois que a aplicação subir entre no navegador no link `localhost:8080/q/dev`
    - Vai abrir uma lista de funções adicionais do quarkus
  - Rodando a aplicação pelo Intellij
    - Adicione uma classe Main na pasta infrastructure
    - Anote a classe com @QuarkusMain
    - Adicione um método main com o código Quarkus.run(args)
- Desenvolvimento — Gerenciamento de candidatos — Serviços — Parte 1
  - Vai utilizar TDD
  - Interessante a utilização da biblioteca `Instancio`
  - O jeito de pensar no desenvolvimento com TDD é diferente
- Desenvolvimento — Gerenciamento de candidatos — Serviços — Parte 2
  - Desenvolvendo o restante dos métodos do CRUD de candidatos
  - Utilizando o `Query Object`
  - `FreeBuilder` não é legal de ser utilizado
  - Comando para rodar o `CI/CD`
  - `./cicd-build.sh election-management`
  - Comando para deploy da aplicação
  - `./cicd-blue-green-deployment.sh election-management 1.0.2`
  - A versão é incrementada a cada nova execução do build
  - Esses comandos só funcionaram no `git bash`
  - URL para visualizar a aplicação: http://localhost:8080/dashboard#/
  - Registros da aplicação: http://logging.private.dio.localhost/
  - A parte de logs não funciona
- Desenvolvimento — Gerenciamento de candidatos — Repositório — Parte 1
  - Migration e Hibernate
  - Querys complexas
  - TestContainers rodando toda a hora, pois deixa um container consumindo memória
  - Conversão do objeto não foi feita com sucesso
  - Não da para ver que comandos ele executa, pois, ele executa com meio segundo
- Desenvolvimento — Gerenciamento de candidatos — Repositório — Parte 2
  - JSON Rest Services
  - DTO: Data Transfer Object
  - Integration Test
- Desenvolvimento — Gerenciamento de candidatos — API — Parte 1
  - Todas as classes terem o mesmo nome é muito ruim para leitura
  - Colocar caminho do diretório para diferenciar o arquivo é muito chato
  - Utilizou o Rest Assured
  - Adicionou o Swagger na aplicação
  - Os testes rodando a todo o momento não é uma coisa boa
- Desenvolvimento — Gerenciamento de candidatos — API — Parte 2
  - Terminando a parte de API da aplicação
  - Adicionando testes de integração
  - Comando para executar teste de integração
  - `./mvnw verify -DskipITs=false -Dquarkus.log.handler.gelf.enabled=false -Dquarkus.opentelemetry.enabled=false -Dquarkus.datasource.jdbc.driver=org.mariadb.jdbc.Driver`
  - A quantidade de containers é tão grande que o próprio professor se perde no que funciona e no que não funciona
  - URL do Jaeger: http://telemetry.private.dio.localhost/
  - URL da aplicação: http://vote.dio.localhost/api/candidates
- Desenvolvimento — Gerenciamento de Eleição — Publish
  - Link da próxima aula: https://github.com/thpoiani/lab-quarkus/tree/video07
  - Gerenciamento de eleições
  - Redis
  - Event Driven
    - Redis Pub/Sub
  - Dados de mock no site https://mockaroo.com/
  - Comando para filtrar containers
    - docker ps | grep redis
  - Comando para acessar o banco de dados
    - docker exec -it 0dacae63ae9c mysql -uquarkus -pquarkus quarkus
  - Comando para acessar o redis
    - docker exec -it 44bbb3b1632b redis-cli
  - Comando para mostrar as chaves no redis
    - keys *
  - Comando para mostrar os dados da chave
    - ZRANGE election:73923f65-75db-4662-8270-494e591c1430 0 -1 WITHSCORES
  - Comando para ler as mensagens postadas no redis
    - SUBSCRIBE elections
  - O `redis` é usado como um `broker` de mensagens
- Desenvolvimento — Aplicação para votação — Parte 1
  - Lifecycle onStartup
    - @Startup: Quando a aplicação for iniciado, a classe será injetada
  - Redis
    - Redis Pub/Sub
      - Comando para adicionar uma eleição
        - ZADD election:election-id 0 "candidate-1" 0 "candidate-2"
      - Comando para publicar a eleição
        - PUBLISH elections election-id
  - Memoization/Caching
  - Reactive
    - Mutiny
      - Mostrou uma forma de trabalhar com linguagem reativa no quarkus
- Desenvolvimento — Aplicação para votação — Parte 2
  - Adicionando o quarkus-cache
  - Utiliza o @CacheResult(cacheName = "memoization") para guardar em memória
  - Uma afirmação muito interessante
    - Existe uma validação na aplicação que não retorna se deu certo ou erro
    - Isso é útil quando alguém tenta realizar um ataque a aplicação de força bruta
    - Quem realizar o ataque não irá saber se funciona ou não
- Desenvolvimento — Gerenciamento de eleição — Sincronismo
  - Utilização de Scheduler
  - Utilização de consulta nativa
  - Precisa dos `inserts` na segunda migração para funcionar
  - Comando para adicionar um voto
    - zincrby election:4e24f52c-aa85-446c-ab2e-6801887ef8e3 1 ff98c649-d71d-4e8a-a08b-d3d2220e8060
- Desenvolvimento — Resultados
  - Qualifier
    - Foi criada uma anotação @Principal para definir quem seria instanciado
  - Rest Client
    - Extensões adicionadas
      - quarkus extension add 'quarkus-rest-client' 'quarkus-rest-client-jackson'
      - quarkus extension add 'quarkus-resteasy-reactive-jackson' 'quarkus-rest-client-mutiny'
  - Server Sent Events
    - @RestStreamElementType deixa a conexão aberta sempre escutando por resultados
  - O `voting-app` funciona como um API Gateway
- Demonstração e encerramento
  - Demonstração
    - Comando do graylog
      - curl -H "Content-Type: application/json" -H "Authorization: Basic YWRtaW46YWRtaW4=" -H "X-Requested-By: curl" -X POST -v -d '{"title":"udp input","configuration":{"recv_buffer_size":262144,"bind_address":"0.0.0.0","port":12201,"decompress_size_limit":8388608},"type":"org.graylog2.inputs.gelf.udp.GELFUDPInput","global":true}' http://logging.private.dio.localhost/api/system/inputs
    - Comando para conectar no banco de dados
      - mysql -h quarkus-database-1 -u election-management-user -pelection-management-password election-management
    - Comando para conectar no redis
      - docker-compose exec -it caching redis-cli
    - URL do graylog
      - logging.private.dio.localhost
    - URL do Jaeger
      - http://telemetry.private.dio.localhost/
    - URL do dashboard da aplicação
      - http://localhost:8080/dashboard#/
    - Comando para escalar o voting-app para 4 containers
      - TAG=1.1.0 docker-compose up -d voting-app --scale voting-app=4 --no-recreate
  - Load Testing
    - Foi feito com python utilizando LOCUST
    - Fazer um random utilizando o JMeter para treinar
    - URL para realizar um POST para votar
      - http://vote.dio.localhost/api/voting/elections/{electionID}/candidates/{candidateID}
    - Exemplo
      - http://vote.dio.localhost/api/voting/elections/2b61db8d-f823-4826-af45-3822b6360fff/candidates/0388f045-5dfb-4bf3-87f9-1be3073d5393
  - Client React
    - `Site` simples em react para mostrar os resultados
  - Recomendou vários desafios para adicionar mais coisas na aplicação

### Desafios de Código Java intermediários: S.O.L.I.D
- 5 desafios sobre SOLID
- Um para cada conceito
- Desafios realizados na plataforma da DIO

## AWS Cloud Computing para `soluções Java`

### Criando a sua conta na AWS
- Apresentação
  - Criação de conta na AWS
- Criando uma conta na AWS
  - Email: fedispatotortora@gmail.com
  - Nome da conta: fedispatotortora
  - Usuário root é o proprietário da conta
- Modelo de responsabilidade compartilhada e entendendo os níveis de gratuidade AWS
  - AWS gerencia os componentes fisicos e a sua segurança
  - O Cliente gerecia os softwares instalados nesses containers
  - Não é feita cobrança para ter uma conta na AWS
  - Mostrando serviços gratuitos
  - Para encontrar serviços gratuitos pesquise por serviços gratuitos AWS
- Conceito do menor privilégio: Criando um usuário e um grupo de usuário
  - IAM: Identity Access Management
  - Não é recomendado utilizar a conta raiz: ela tem acesso a tudo
  - O correto é conceder ao usuário o minimo necessário de privilégios na AWS
  - Utilizar grupos para gerenciar permissões
  - Explicação de como criar um usuário
  - MFA criado com sucesso
  - Passo a passo para criar usuários
    - Acessar (opção) usuários
    - Criar usuário
      - fedispato-admin
    - Criar Grupo
      - admin-group
    - Revisar e Criar
  - Configurar usuário
    - Entrar no usuário para edição na parte de IAM à conta root
    - Acessar credenciais de segurança
    - Copiar endereço de acesso no console para usuários
    - Clicar em Habilitar acesso ao console
      - Habilitar
      - Senha personalizada
      - Aplicar
  - Precisa habilitar o MFA para a conta root e conta admin
- Conhecendo o painel de faturamento da AWS
  - Na barra de pesquisa procurar por `Billing`
  - Na conta nova não tem nenhum dado, pois acabou de ser criada
  - Para acessar pela conta admin precisa configurar
  - Vou deixar somente na conta root por enquanto
- Encerramento
  - Finalizado a criação de conta na AWS

### Introdução ao conceito de `Cloud`
- Afinal, o que é cloud computing
  - Objetivo é entender o que é `cloud computing` e os seus benefícios
  - Mundo pré cloud
    - Modelo cliente servidor
    - Ambientes on-premises
    - Virtualização
  - Beneficio chave
    - Pagamento conforme uso
  - Definição 
    - É a entrega de recursos de `TI` sob demanda por meio da Internet com definição de preço de pagamento conforme uso
- Benefícios de cloud computing
  - Troque despesas iniciais por despesas variáveis
  - Pare de tentar adivinhar a capacidade
  - Beneficie-se de enormes economias de escala
  - Aumente a velocidade e agilidade
  - Ter alcance global em minutos
- Modelos de serviços
  - Também chamado modelos de computação em nuvem
  - Escolha com base no usuário do serviço e o seu objetivo/responsabilidade
  - IaaS
    - Infraestrutura como serviço
    - Componentes básicos de TI
    - Disco, memória, CPU
    - Usuário: Sysadmin
    - Usuário gerencia infraestrutura
    - Amazon EC2
  - PaaS
    - Plataforma como serviço
    - Plataforma para implantar (deploy)
    - Não se preocupe com infraestrutura
    - Usuários: Desenvolvedores
    - Elastic Beanstalk
  - Saas
    - `Software` como serviço
    - Produto completo, executado e gerenciado pelo provedor
    - Não se preocupe com infraestrutura
    - Pense apenas em utilizar
    - Gmail
- Modelos de implantação
  - Se relaciona com como os recursos de computação estão estruturados e distribuídos
  - É onde o serviço está implantado
  - On-premises
  - Híbrido
  - Cloud

### Infraestrutura Global AWS
- O que é infraestrutura global AWS
  - Compreender o que é infraestrutura global AWS
  - Estrutura adjacente bem como também conhecer sobre provisão de recursos e interação com serviços
  - Infraestrutura de datacenters em todo o mundo que fornecem os diversos serviços que pode utilizar na AWS
  - Composto por regiões e zonas de disponibilidade
  - Vantagens: Alta disponibilidade, Tolerância a falhas
  - 87 zonas de disponibilidade em 27 regiões geográficas
  - Planos divulgados para mais 21 zonas de disponibilidade e outras 7 regiões da AWS
  - Austrália, Canadá, Índia, Israel, Nova Zelândia, Espanha e Suiça
- Regiões e zonas de disponibilidade
  - Regiões
    - Locais onde são hospedados os (data) centers da AWS
    - Cada região possuem locais isolados chamados zonas de disponibilidade
    - Todas as regiões são conectadas com rede de alta velocidade
    - Isolamento de dados
    - Regulação de dados local
  - Zonas de disponibilidade
    - Também chamadas de AZs (Availibility Zones)
    - Agrupamento de datacenters isolados dentro de uma região
    - Rede, energia e conectividade redundates
    - Próximas o suficiente para manter baixa latência, longe o suficiente para evitar que um desastre afete mais de uma AZ
    - Recomendação: Execute pelo menos em duas AZs
- Pontos de presença
  - Chamados de `Edge Locations`, locais de borda ou redes de borda
  - Funcionam como pontos específicos pelo globo para distribuir conteúdo de forma rápida
  - Exemplos de serviços nos locais de borda: Route 53(DNS) e Cloud Front(CDN)
  - Amazon CloudFront
    - Serviço de entrega de conteúdo: CDN
    - Melhora o desempenho do seu serviço (baixa latência, alta taxa de transferência)
    - Provê conteúdo o mais próximo possível do seu usuário
  - Amazon Route 53
    - Serviço de DNS
    - Ajuda os clientes a redirecionar corretamente as requisições
- Provisionamento de recursos na AWS
  - Console de gerenciamento
    - Acessar via URL na inteface web
      - https://aws.amazon.com/pt/console/
  - AWS CLI
    - Acessar via CLI pelo windows, linux ou mac
    - Instalado na sua máquina
    - Opera com APIs da AWS através de linha de comando
  - SDKs
    - Utilizado dentro da sua API
    - Acesso as APIs AWS através de SDK
    - SDK possui versões em diversas linguagens, como: Java, C#, Go, Python e Javascript
  - Provisionamento de infraestrutura
    - Elastic Beanstalk
      - Automatiza o processo de deploy da aplicação
    - CloudFormation
      - IaaC
      - Automatiza o processo de construção de infraestrutura na AWS

### Computação em AWS
- Conhecer os principais serviços de computação na AWS
- Elastic Compute Cloud - EC2
  - Para montar um, data center precisa de muitas configurações
  - É muito custoso ter uma estrutura própria
  - E se todo o investimento nesse data center não for necessário dada a sua demanda?
  - E se um dia seu negócio crescer e a infraestrutura não suportar a demanda de usuários?
  - Seria ideal ter
    - Economia de recursos e custo
    - Escalabilidade
    - Elasticidade
    - Disponibilidade
  - EC2
    - Capacidade computacional segura e redimensionável
    - Computação: CPU, Memória, Rede, Armazenamento, Sistema operacional
    - Definição de preço conforme uso e modalidades específicas a necessidade
    - Instâncias com tipos otimizados para a sua atividade
  - Conceito chave/instância
    - Servidor virtual na nuvem AWS
    - Possui configurações de memória, CPU, disco, rede e sistema operacional
  - Tipos de instância
    - Diferentes tipos para casos de uso diferentes
    - Várias combinações diferentes de configurações
    - Uso geral
      - Equilíbrio de recursos de computação, memória e rede
      - Indicado para servidores de aplicativos, jogos, backend, banco de dados pequenos
    - Otimizadas para computação
      - Ideal para cargas de trabalho que exigem processadores de alto desempenho
      - Pode ser usado para os mesmos casos de uso da categoria de uso geral
      - Quando se deseja um melhor desempenho
      - Ideal também para processamento em lote
    - Otimizadas para memória
      - Projeto para alto desempenho no processamento de abundantes quantidades de informações na memória
      - Exemplo: Banco de dados de alto desempenho, processamento em tempo real de dados
    - Computação acelerada
      - Usa aceleração de `hardware` ou coprocessadores para executar algumas funções de forma mais eficiente do que em `software` executado direto na CPU
      - Exemplos de casos de uso: Cálculo de ponto flutuante, processamento de gráficos e correspondência de padrões de dados
    - Otimizadas para armazenamento
      - Ideal para cargas de trabalho que exigem acesso de leitura e gravação com grande volume de dados
      - Casos de uso: Sistemas de arquivos distribuídos, Data warehouse, sistema de processamento de transações `online`
- Amazon EC2 Autoscaling
  - Precisa resolver o problema de capacidade da máquina
  - Ao elevar ao máximo é possível atender todos os clientes, mas fica com uma parte sem utilizar
  - Outra possibilidade é deixar na média, mas pode ter problema para utilizar o programa
  - Escalar conforme necessidade
  - O EC2 Autoscalign provê escalabilidade horizontal para os seus serviços
  - Melhora a tolerância a falhas com identificação de instâncias indisponíveis e implantação multi-AZ
  - Melhor gerenciamento de custos
  - Configuração
    - Tamanho minimo
    - Capacidade desejada
    - Escala conforme necessidade
    - Tamanho máximo
  - Abordagens
    - Scaling Preditivo
      - Já sabe quando irão ocorrer os picos de utilização
    - Scaling Dinâmico
      - Ao atingir uma meta de utilização o serviço é escalado
    - É possível combinar os dois
- Elastic Load Balancing - ELB
  - Utilizado quando uma instância recebe muitas requisições
  - Ele decide para qual instância será enviada uma requisição
  - Balanceamento de carga de aplicação, gateway e rede
  - Escopo regional
  - Escala de forma automática, sem custos
  - Junto ao EC2 Autoscaling permite criar aplicações altamente disponíveis
- Serviços de mensageria
  - SQS
    - Simple Queue Service
    - É um serviço de fila
    - É assincrona
    - Sistema de enfileiramento de mensagens
    - Um usuário envia uma mensagem para a fila, o outro usuário lê, processa e exclui da fila
  - SNS
    - Simple Notification Service
    - Também é um serviço de mensageria
    - É configurado os serviços com interesse nessa mensagem
    - Sistema pub/sub
    - Utiliza tópicos como estrutura
    - Usuário publica mensagens no tópico e assinantes escutam
- Computação sem servidor
  - Também chamado pelo termo `Serveless`
  - O termo sem servidor significa que o código é executado em servidores sem precisar provisionar ou gerenciar esses servidores
  - Capacidade automaticamente ajustada pelo serviço, sem necessidade de nenhuma configuração
  - AWS Lambda
    - Execução de código sem provisionar servidores
    - Código organizado em funções
    - Pode escolher a linguagem de programação da sua preferência
    - Executa a partir de eventos ou chamadas diretas a API do Lambda
- Containers em AWS
  - Forma padrão de empacotar o seu aplicativo num único objeto
  - Executados como processos isolados
  - Docker
  - Construa uma imagem
  - Faça uma esteira de deploy
  - Rode em qualquer lugar
  - Escala rapidamente
  - ECR: Elastic Container Registry
    - Escreva um código
    - Ele faz o controle de todas as imagens de uma aplicação
    - Roda containers no ECS, EKS e On-Premises
    - ECS é um serviço de execução de containers docker na AWS
  - EKS: Elastic Kubernetes Service
    - Provisiona um EKS Cluster
    - Deploy dos containers
    - Conecta no EKS
    - Roda aplicaçãoes kubernetes
  - AWS Fargate
    - Pode usar ECS ou EKS
    - Tem uma dificuldade menor para utilizar as aplicações
    - Consegue rodar de uma forma mais rápida

### Redes em AWS
- Conhecer os principais conceitos de rede relacionado a AWS
- Amazon VPC
  - VPC: Virtual Private Cloud
  - Permite construir e configurar redes virtuais na AWS
  - Sub-redes: Privadas e públicas
  - Tudo começa num VPC
- Conectividade com AWS
  - Region
  - VPC
  - AZ (Availability Zone)
  - Public Subnet
  - Gateway da Internet
  - Gateway Privado Virtual (Virtual Private Gateway)
    - Para conectar uma rede privada na rede da AWS precisa de um 
  - AWS Direct Connect
    - Servidor privado conectando diretamente na AWS
- Sub-redes e listas de controle de acesso
  - Como que os dados trafegam numa VPC
    - Gateway de internet
  - Network ACLs
    - Lista de controle de acesso
    - Controle de tráfego de entrada e saída de sub-redes
    - Comportamenteo stateless
    - Por padrão, permite todo o tráfego de entrada e saída
  - Segurança para recursos
  - Grupos de segurança
    - Lista de controle de acesso à rede
    - Mais uma camada de segurança a nivel de segurança EC2
    - Controle de tráfego de entrada e saída de instâncias EC2
    - Comportamento Stateful
    - Por padrão, nega todo o tráfego de entrada e permite todo o tráfego de saída
  - Revisando
    - Comportamento Stateless
      - `Network ACLs`: Segurança a nível de subnet
      - Grupos de segurança: Por padrão permite todo o tráfego de entrada e saída
    - Comportamento Stateful
      - `Network ACLs`: Segurança em nível de instância EC2
      - Grupos de segurança: Por padrão nega todo o tráfego de entrada e permite todo fluxo de saída

### Armazenamento e banco de dados AWS
- Armazenamento de dados em nuvem
  - Tipos de armazenamento
    - Armazenamento de objetos (Object Storage)
      - Dados como objetos (arquivos e metadados)
      - Dados não estruturados
      - Casos de uso: Data lakes, Mídias, Backup e recuperação
    - Armazenamento de arquivos (File Storage)
      - Sistema de arquivos compartilhados
      - Permite acesso por servidores, aplicações e usuários
      - Analogia com pastas compartilhadas numa rede
      - Casos de uso: Ferramentas de desenvolvimento, diretórios pessoais
    - Armazenamento de blocos (Block Storage)
      - HDD, SSD
      - Dispositivo com diferentes configurações de leitura e escrita
      - Casos de uso: Máquinas virtuais, containers, banco de dados
- Amazon Elastic Block Store: EBS
  - Volume Instance Store
    - Armazenamento de blocos
    - Discos anexados fisicamente ao computador `host`
    - Ideal para dados de armazenamento temporário como `buffers`, `caches` e `dados rascunho`
  - Dados serão perdidos se
    - Falha de disco de uma unidade
    - Instância parada
    - Instância hiberna
    - Instância encerrada
  - Armazenamento de blocos
  - Block, blocos = HD, físico
  - Projetado para Amazon Elastic Compute Cloud (EC2)
  - HDs são chamados "volumes"
  - Como funciona
    - Defina o tipo de volume
    - Escolha o tamanho e configurações
    - Anexe o volume numa instância EC2
  - HDD
    - Mais lento
    - Mais barato
    - Dois tipos: Disco rígido frio e otimizado para throughput
  - SSD
    - Mais rápido
    - Mais caro
    - Dois tipos: Volumes SSD de uso geral e IOPS provisionados
  - Como funcionam os backups
    - Snapshots
    - Backup incremental
- Amazon S3
  - Serviço de armazenamento de objetos
  - Simple Storage Service
  - Possui dados, metadados e chave
  - Composição de um objeto
  - Chave: Nome que atribui ao objeto. Usado para recuperar o objeto
  - Valor: O conteúdo que está armazenado
  - Metadados: Um conjunto de pares de nome-valor com o qual é possível armazenar informações relacionadas ao objeto
  - Objetos estão no bucket
  - Buckets S3
    - Antes de um ‘upload’ do seu objeto, precisa criar um
    - É um container para objetos armazenados no `Amazon S3`
    - Pode armazenar qualquer número de objetos num bucket
    - Objetos podem ter de 0 até 5 ‘terabytes’ de tamanho
    - Pode ter até 100 buckets na sua conta
    - Pode controlar o acesso por objeto
    - Utilizar versionamento de objetos
  - Casos de uso
    - Data lakes
    - Arquivamento de dados
    - Hospedagem de `sites estáticos`
  - Classes de armazenamento
    - Categorias para adequar melhor as necessidades de negócio e custo
    - Fatores importantes na seleção de uma categoria
    - Com que frequência você planeja recuperar os seus dados?
    - Os seus dados precisam estar muito ou pouco disponíveis
    - S3 Standard
      - Projetado para dados acessados com frequência
      - Armazena dados num mínimo de três zonas de disponibilidade
      - Boa escolha para diversos casos de uso como `sites`, distribuição de conteúdo e análise de dados
      - Custo mais alto
    - S3 Standard-Infrequent Access (S3 Standard-IA)
      - Semelhante ao `S3 Standard`
      - Armazena dados num mínimo de três zonas de disponibilidade
      - Ideal para dados acessados com pouca frequência
      - Taxa por GB de armazenamento e recuperação mais baixo
    - S3 One Zone-Infrequent Access (S3 One Zone - IA)
      - Tem um preço de armazenamento menor do que o `S3 Standard - IA`
      - Armazena dados numa única zona de disponibilidade
      - Cenários: Quer economizar custos com armazenamento
      - Pode reproduzir facilmente os seus dados em caso de falha na zona de disponibilidade
    - S3 intelligent-Tiering
      - Ideal para dados com padrões de acesso desconhecidos ou em alteração
      - Gerencia automaticamente o ciclo de vida dos objetos armazenados otimizando custos
      - Requer uma pequena taxa mensal de monitoramento e automação por objeto
    - S3 Glacier Instant Retrieval
      - Ideal para dados de longa duração
      - Raramente acessados, mas que exigem recuperação rápida (milissegundos)
      - Oferece acesso tão rápido quanto `Standard` e `Standard-IA`
      - Ideal para dados acessados uma vez por trimestre
    - S3 Glacier Flexible Retrieval
      - Para dados que não requerem acesso imediato
      - Ideal para casos de uso de `backups` não urgentes, recuperação de desastres
      - Usuário pode escolher qual velocidade de recuperação
      - Ideal para dados acessados 1 ou 2 vezes por ano
    - S3 Glacier Deep Archive
      - Suporte a retenção e preservação digital de longo prazo para dados que podem ser acessados 1 ou 2 vezes por ano
      - Ideal para empresas que precisam manter dados por conformidades legais por 7 a 10 anos
      - Recuperação de dados em até 12 horas
- EFS: Amazon Elastic File System
  - Fornece um sistema de arquivos 
  - Servless e totalmente elástico
  - Escala até petabytes
  - Aumentar e diminuir conforme edição e remoção de arquivos
  - Compatível com o protocolo NFS (Network file system)
  - Pode ser acessado por EC2, lambda e ECS
  - Acesso simultâneo aos mesmos dados sem problemas de desempenho
  - Classes de armazenamento
    - Padrão (instância regional): `Standard` e `Standard-IA` (Infrequent Access)
    - Uma AZ: One Zone e One Zone - IA (Infrequent Access)
- Amazon Relational Database Service
  - Banco de dados relacional
    - Relação de dados
    - Facilita a compreensão das informações
    - SQL como linguagem de consulta
    - RDBMS (Sistema de gerenciamento de banco de dados)
    - Vendors
      - Postgres
      - Oracle
      - MySQL
      - SQL Server
    - Utilizado com o EC2
    - Usa, você gerencia
  - RDS
    - Facilita configuração e provisionamento de `hardware`
    - `Patches` automatizados
    - Backups
    - Redundância
    - Failover e recuperação de desastres
    - Mecanismos compatíveis
      - MySQL
      - PostgreSQL
      - MariaDB
      - Oracle
      - SQL Server
  - Amazon Aurora
    - Servless
    - Mecanismos compatíveis: PostgreSQL e MySQL
    - Preço 1/10 de outros vendors
    - Replicação multirregional
    - Até 15 réplicas de leituras
    - Backup contínuo via S3
- DynamoDB
  - NoSQL
  - Gerenciado (Servless)
  - Desempenho abaixo de 10 milissegundos
  - Escala automaticamente
  - Replicação de dados regional
  - Caso de uso: Muitos dados, baixa latência
  - A estrutura dos dados é um `JSON`
  - Tabelas: Coleção de dados
  - Item: Grupo de atributos identificável
  - Atributo: Dados existentes dentro de cada ‘item’
- Outros serviços de banco de dados
  - A necessidade de negócio escolhe o banco de dados
  - Amazon DocumentDB
    - Banco de dados de documentos
    - Gerenciamento de conteúdo
    - Catálogos, perfis de usuário
    - Compatível com cargas de trabalho MongoDB
  - Amazon Neptune
    - Redes sociais, mecanismos de recomendação, descoberta de fraude e gráficos de conhecimento
    - Banco de dados de grafos
  - Amazon QLDB
    - `Quantum Ledger Database`
    - Banco de dados serviço `ledger`
    - Imutabilidade
    - Indicado para históricos, registros digitais, transações financeiras
  - Amazon DynamoDB Accelerator
    - Chamado também de DAX
    - Camada de `cache` nativa para otimizar tempo de leitura de dados
  - Amazon Elasticache
    - Camada de cache sobre banco de dados
    - Compatível com Redis e Memcached
- Big Data com Amazon Redshift
  - Existem muitas fontes de dados
  - Perguntas
    - Quantas vendas o aplicativo fez desde o início do lançamento?
    - Quantos usuários fizeram cadastro na última hora?
  - Contexto
    - Velocidade de geração de dados
    - Variedade de fontes de dados
    - Quando os dados precisam responder com inteligência de negócio
  - Amazon Redshift
    - Serviço de data warehouse para análise de Big Data
    - Oferece coletar informações de muitas fontes de dados
    - Projeta relações e tendências de dados
    - Usando redshift spectrum é possível rodar comandos SQL em cima de todas as fontes de dados agrupadas

### Redução de custos em farmácias com AWS
- Missão: Operação farmacêutica
  - Entender um momento de uma empresa que não utiliza nuvem
  - Criar um arquivo de texto explicando as vantagens de 3 ferramentas da nuvem
- Modelo de relatório de entrega
  - Tudo que estiver entre colchetes deve ser alterado
- Entendendo o desafio
  - Entrega do projeto pelo github

### Publicando sua API REST na nuvem usando Spring Boot 3, Java 17 e Railway
- O que vamos desenvolver neste lab
  - Projeto de API desde a criação até o deploy na AWS
  - Criação e versionamento da API
    - Spring Initialzr e GitHub
  - Abstração e Modelagem do Domínio
    - Figma, ChatGPT (Mermaid) e JPA
  - Implementação do backend
    - Spring Boot e Java 17
  - Deploy e monitoramento
    - Railway (PostgreSQL e CI/CD da API)
  - Desafio: Cria a sua própria API
    - Explore um novo domínio de aplicação a sua escolha
- Criação e importação do projeto
  - Configurando com o Spring Initializr
  - Importação feita no Eclipse e Intellij
  - Será utilizado o Intellij
- Versionamento no github
  - Enviando projeto para o Github pelo Intellij
- Abstração inicial do domínio do figma
  - Pegando os dados necessários no Figma
  - Objeto antes da organização
  ```
  {
    "name": "Tortora",
    "accountNumber": "0000000-0",
    "accountAgency": "0000",
    "accountBalance": 1324.64,
    "accountLimit": 1000.00,
    "pixIcon": "",
    "pixDescription": "PIX",
    "payIcon": "",
    "payDescription": "Pagar",
    "transferIcon": "",
    "transferDescription": "Transferir",
    "cardNumber": "xxxx xxxx xxxx 0000",
    "cardLimit": 1000,
    "newIcon": "",
    "newDescription": "O Tortora tem soluções de crédito sob medida para você"
  }
  ```
  - Objeto depois da organização
  ```
  {
    "name": "Tortora",
    "account": {
      "number": "0000000-0",
      "agency": "0000",
      "balance": 1324.64,
      "limit": 1000.00
    },
    "features": [
      {
        "icon": "URL",
        "description": "PIX"
      },
      {
        "icon": "URL",
        "description": "Pagar"
      },
      {
        "icon": "URL",
        "description": "Transferir"
      }
    ],
    "card": {
      "number": "xxxx xxxx xxxx 0000",
      "limit": 1000 
    },
    "news": [
      {
        "icon": "URL",
        "description": "O Tortora tem soluções de crédito sob medida para você"
      }
    ]
  }
  ```
- Diagrama de classes com ChatGPT e Mermaid
  - Comando para dar ao ChatGPT
    - Gere um diagrama de classes (usando a sintaxe mermaid) tendo em vista o seguinte JSON
      que representa um usuário de um banco. Mantenha uma estrutura simples e fiel ao modelo
      que vou passar. Além disso, mantenha o nome das classes em inglês.
    - Passar o JSON gerado
  - Será gerado um diagrama de classes que pode ser visualizado no github
  - Site da Mermaid
    - mermaid.js.org
- Mapeamento Objeto Relacional (ORM)
  - Explicando as anotações do JPA
  - Criando as classes e adicionando anotações
  - Configurações do arquivo `application.yml`
  - Acessando o banco de dados `H2` pelo console
  - O endereço para acessar é:
    - `localhost:8080/h2-console`
  - Dados para acessar o banco
    - JDBC URL: jdbc:h2:mem:ftd2024
    - Username: ftd2024
- Hotfix 'precision' e 'scale'
  - Precision precisa ser 13 e o scale 2
- Implementando a camada de negócio
  - Implementando camada de negócio
  - Utiliza `interface` para não expor implementação
  - Algumas exceptions e implementando a camada de serviço bem simples
- Expondo endpoints REST e testando a API
  - Criando a camada de controller
  - Adicionando open API para realizar testes
  - Endereço para acessar o Swagger
    - http://localhost:8080/swagger-ui/index.html#
- Tratamento de exceções em APIs REST
  - Quebrando a API para adicionar validações
  - Utilização do @RestControllerAdvice
  - Tratamento dos erros
- Provisionando o PostgreSQL (Railway) e criando o perfil de PRD
  - Endereço do railway
    - railway.app
    - Criando arquivo para deploy em produção
  - Na primeira execução precisa configurar o arquivo application-prd.yml com `ddl-auto: create`
  - Depois da primeira execução pode deixar como validate para não criar as tabelas novamente
- Deploy da API na nuvem (Railway)
  - Configurar aplicação para rodar no railway
  - Alterar o build.gradle
  - Adicionar o código abaixo
```
tasks.jar {
  manifest {
      attributes["Main-Class"] = "ti.tortora.Application"
  }
}
```
  - Criar arquivo Procfile
  - Executar task do gradle bootJar
  - Pegar caminho do jar dentro do build do gradle
  - Exemplo
    - build/libs/spring-api-railway-0.0.1-SNAPSHOT.jar
  - Se não rodar o projeto
  - Atualizar versão do gradle dentro do gradle-wrapper.properties para 7.6.1
  - Mostra algumas configurções do `railway`
  - Endereço do aplicativo
    - tortora-railway.up.railway.app
  - Precisa configurar variaveis de ambiente para produção
  - Project Settings
  - Environments: production
  - Shared Variables: production
    - SPRING_PROFILES_ACTIVE = prd
  - Precisa configurar dentro do aplicativo spring no railway as variaveis de ambiente
  - Essa variaveis estão dentro do Intellij
  - Também precisa configurar a porta da aplicação além das configurações do Intellij
  - PORT = 8080
  - Endereço do Swagger em produção
    - https://tortora-railway.up.railway.app/swagger-ui/index.html
- Correção de CORS e conclusão
  - Faltando somente uma anotação no Application
  - Testando a aplicação em produção
- Desafio! Crie a sua própria API
  - Criar a sua própria API utilizando o que foi ensinado
  - Criar a API de salário e economias por tempo
- Entendendo o desafio
  - 

### Avalie este Bootcamp
- Falar o que achou do bootcamp
- Analisar todas as anotações